<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pose Estimation 라벨링 툴 (Material Design 3)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    <style>
        :root {
            --md-sys-color-primary: #a8c7fa;
            --md-sys-color-on-primary: #003258;
            --md-sys-color-primary-container: #00497d;
            --md-sys-color-on-primary-container: #d3e4ff;
            --md-sys-color-secondary: #bcc6dc;
            --md-sys-color-on-secondary: #283141;
            --md-sys-color-secondary-container: #3e4759;
            --md-sys-color-on-secondary-container: #d8e2f9;
            --md-sys-color-error: #f2b8b5;
            --md-sys-color-error-container: #8c1d18;
            --md-sys-color-on-error-container: #f9dedc;
            --md-sys-color-surface-container-low: #191c20;
            --md-sys-color-surface-container: #1d2024;
            --md-sys-color-surface-container-high: #282b2f;
            --md-sys-color-surface: #111318;
            --md-sys-color-on-surface: #e2e2e9;
            --md-sys-color-on-surface-variant: #c2c6d2;
            --md-sys-color-outline: #8c909c;
            --md-sys-color-outline-variant: #42474e;
        }

        html, body { height: 100%; overflow: hidden; }
        body {
            font-family: 'Inter', sans-serif;
            display: flex;
            flex-direction: column;
            background-color: var(--md-sys-color-surface);
            color: var(--md-sys-color-on-surface);
        }

        .btn {
            position: relative; overflow: hidden; display: inline-flex; align-items: center; justify-content: center;
            padding: 0 24px; height: 40px; border-radius: 20px; font-size: 0.875rem; font-weight: 500;
            border: 1px solid transparent; transition: background-color 0.2s, box-shadow 0.2s;
        }
        .btn:disabled { background-color: rgba(226, 226, 233, 0.12); color: rgba(226, 226, 233, 0.38); cursor: not-allowed; }
        .btn::before { content: ''; position: absolute; top: 0; left: 0; right: 0; bottom: 0; background-color: currentColor; opacity: 0; transition: opacity 0.2s; }
        .btn:hover::before { opacity: 0.08; }
        .btn-filled { background-color: var(--md-sys-color-primary); color: var(--md-sys-color-on-primary); }
        .btn-tonal { background-color: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container); }
        .btn-danger { background-color: var(--md-sys-color-error-container); color: var(--md-sys-color-on-error-container); }
        .btn-icon { padding: 0; width: 40px; height: 40px; border-radius: 50%; }

        #mainCanvas { cursor: crosshair; image-rendering: pixelated; display: block; }
        #canvas-wrapper { background-color: #000; }
        .object-item { border-radius: 8px; transition: background-color 0.2s; }
        .object-item.selected { background-color: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container); }
        .keypoint-item.selected { background-color: var(--md-sys-color-surface-container-high); }
        
        input[type=number] {
            background-color: var(--md-sys-color-surface-container-low);
            border: 1px solid var(--md-sys-color-outline-variant); border-radius: 4px;
        }
        input[type=number]::-webkit-inner-spin-button, 
        input[type=number]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type=number] { -moz-appearance: textfield; }

        #toast-popup {
            position: fixed;
            bottom: 2rem;
            left: 50%;
            transform: translate(-50%, 200%);
            padding: 12px 24px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            opacity: 0;
            transition: opacity 0.3s ease, transform 0.4s cubic-bezier(0.25, 1, 0.5, 1);
            z-index: 100;
            pointer-events: none;
        }
        #toast-popup.show {
            opacity: 1;
            transform: translate(-50%, 0);
        }
        #toast-popup.success { background-color: var(--md-sys-color-primary-container); color: var(--md-sys-color-on-primary-container); }
        #toast-popup.error { background-color: var(--md-sys-color-error-container); color: var(--md-sys-color-error); }
        #toast-popup.info { background-color: var(--md-sys-color-secondary-container); color: var(--md-sys-color-on-secondary-container); }
    </style>
</head>
<body>

    <!-- 상단 툴박스 -->
    <header class="p-2 shadow-md flex-shrink-0 flex items-center gap-2" style="background-color: var(--md-sys-color-surface-container); border-bottom: 1px solid var(--md-sys-color-outline-variant);">
        <svg class="w-8 h-8 text-blue-400 mx-2" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M4 8.25C4 7.55964 4.55964 7 5.25 7H18.75C19.4404 7 20 7.55964 20 8.25V15.75C20 16.4404 19.4404 17 18.75 17H5.25C4.55964 17 4 16.4404 4 15.75V8.25Z" stroke="currentColor" stroke-width="1.5"></path><path d="M7.5 7V5.5C7.5 4.39543 8.39543 3.5 9.5 3.5H14.5C15.6046 3.5 16.5 4.39543 16.5 5.5V7" stroke="currentColor" stroke-width="1.5"></path><path d="M14.5 19.5V21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M9.5 19.5V21" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M12 12V14.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M12 9.5V8.5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M9 12H7" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path><path d="M17 12H15" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"></path></svg>
        <div class="h-8 w-px" style="background-color: var(--md-sys-color-outline-variant);"></div>
        <input type="file" id="configLoader" accept=".json" class="hidden">
        <button id="btnLoadConfig" class="btn btn-tonal">Config 열기</button>
        
        <input type="file" id="dirLoader" webkitdirectory multiple class="hidden">
        <button id="btnLoadDir" class="btn btn-tonal" disabled>이미지 폴더 열기</button>

        <button id="btnSave" class="btn btn-filled" disabled>JSON 저장 (S)</button>
        
        <div class="flex-grow"></div>

        <div class="flex items-center gap-2 mr-2">
            <button id="btnPrev" class="btn btn-icon btn-tonal" disabled title="이전 이미지 (←)"></button>
            <p id="imageProgress" class="text-sm w-20 text-center" style="color: var(--md-sys-color-on-surface-variant);">0 / 0</p>
            <button id="btnNext" class="btn btn-icon btn-tonal" disabled title="다음 이미지 (→)"></button>
        </div>
    </header>

    <!-- 메인 컨텐츠 영역 -->
    <div class="flex-grow flex p-4 gap-4 overflow-hidden">
        <!-- 중앙 캔버스 -->
        <main id="canvas-wrapper" class="flex-grow rounded-2xl shadow-lg flex items-center justify-center overflow-hidden relative" style="background-color: #000;">
            <canvas id="mainCanvas" class="rounded-md shadow-inner"></canvas>
            <div id="mode-indicator" class="absolute top-2 left-2 text-white text-xs font-bold px-2 py-1 rounded hidden"></div>
            <div id="canvas-loader" class="absolute inset-0 bg-black bg-opacity-50 flex-col items-center justify-center text-white text-lg hidden"></div>
        </main>

        <!-- 오른쪽 패널 -->
        <aside class="w-1/4 lg:w-1/5 rounded-2xl shadow-lg flex flex-col" style="background-color: var(--md-sys-color-surface-container);">
            <div class="p-4 border-b" style="border-color: var(--md-sys-color-outline-variant);">
                <button id="btnAddObject" class="btn btn-filled w-full" disabled>+ 객체 추가 (A)</button>
            </div>
            <div class="flex-grow overflow-y-auto">
                <div id="config-help" class="p-4 text-sm" style="color: var(--md-sys-color-on-surface-variant);"></div>
                <div id="object-list-wrapper" class="p-2 space-y-2"></div>
                <div id="details-wrapper" class="p-2 border-t hidden" style="border-color: var(--md-sys-color-outline-variant);"></div>
            </div>
        </aside>
    </div>
    
    <footer class="p-2 shadow-inner flex-shrink-0 flex justify-between items-center text-sm" style="background-color: var(--md-sys-color-surface-container-high); border-top: 1px solid var(--md-sys-color-outline-variant);"></footer>

    <div id="toast-popup"></div>

    <script>
    // --- 전역 상태 및 설정 ---
    let config = null, imageFiles = [], jsonFiles = [];
    let currentImageIndex = -1, currentImage = null;
    let annotationData = {};
    let history = [];
    let currentHistoryIndex = -1;

    const appState = {
        mode: 'IDLE',
        selectedObjectIndex: -1,
        selectedPointIndex: -1,
        drawingBboxStartPoint: null,
        currentBbox: null,
        isPanning: false,
        isDraggingPoint: false,
        isDraggingBbox: false,
        isResizingBbox: false,
        resizeHandle: null,
        lastPanPoint: { x: 0, y: 0 },
        draggingPointInfo: { objIndex: -1, ptIndex: -1 },
        lastMouseWorldPos: null,
        isAltDown: false,
    };

    let notificationTimeout;

    // --- DOM 요소 ---
    const ui = {};
    
    let transform = { scale: 1, offsetX: 0, offsetY: 0 };
    
    // --- UI 업데이트 ---
    function updateAllUI() {
        updateHelpUI();
        updateObjectListUI();
        updateDetailsPanelUI();
        updateInfoBarUI();
        updateModeIndicatorUI();
    }

    function updateModeIndicatorUI() {
        const indicator = ui.modeIndicator;
        indicator.classList.remove('bg-yellow-500', 'text-black');
        indicator.style.backgroundColor = '';
        indicator.style.color = '';

        if (appState.mode === 'DRAWING_BBOX') {
            indicator.textContent = 'BBOX 그리기 모드';
            indicator.classList.add('bg-yellow-500', 'text-black');
            indicator.classList.remove('hidden');
        } else if (appState.mode === 'EDITING_POSE' && appState.selectedPointIndex !== -1) {
            indicator.textContent = '랜드마크 그리기 모드';
            indicator.style.backgroundColor = 'var(--md-sys-color-primary)';
            indicator.style.color = 'var(--md-sys-color-on-primary)';
            indicator.classList.remove('hidden');
        } else {
            indicator.classList.add('hidden');
        }
    }

    function updateHelpUI() {
        const showHelp = !config || imageFiles.length === 0;
        ui.configHelp.classList.toggle('hidden', !showHelp);
        ui.objectListWrapper.classList.toggle('hidden', showHelp);
        ui.detailsWrapper.classList.toggle('hidden', showHelp);

        if (!config) {
            ui.btnAddObject.disabled = true;
            ui.configHelp.innerHTML = `
                <h3 class="font-bold text-white mb-2">1. Config 파일을 로드하세요.</h3>
                <p>라벨의 이름과 뼈대(skeleton) 구조를 정의하는 JSON 파일입니다.</p>
                <p class="mt-2">예시 포맷:</p>
                <pre class="bg-gray-900 p-2 rounded-md mt-1 text-xs whitespace-pre-wrap"><code>{
  "labels": ["코", "눈", ...],
  "skeleton": [ [0, 1], [0, 2], ... ]
}</code></pre>
            `;
        } else if (imageFiles.length === 0) {
            ui.btnAddObject.disabled = true;
            ui.configHelp.innerHTML = `
                <h3 class="font-bold text-white mb-2">2. 이미지 폴더를 열어주세요.</h3>
                <p>라벨링할 이미지가 포함된 폴더를 선택합니다.</p>
            `;
        } else {
            ui.btnAddObject.disabled = false;
        }
    }

    function updateObjectListUI() {
        ui.objectListWrapper.innerHTML = '';
        const objects = annotationData[imageFiles[currentImageIndex]?.name]?.objects || [];
        if (objects.length === 0) {
            ui.objectListWrapper.innerHTML = `<p class="text-center text-gray-500 p-4">객체가 없습니다. <br>'A' 키를 눌러 추가하세요.</p>`;
            ui.detailsWrapper.classList.add('hidden');
            return;
        }

        objects.forEach((obj, index) => {
            const item = document.createElement('div');
            item.className = 'object-item p-3 rounded-lg cursor-pointer hover:bg-gray-700 transition-colors flex justify-between items-center';
            if (index === appState.selectedObjectIndex) item.classList.add('selected');
            item.innerHTML = `<span>객체 ${index + 1}</span>`;
            item.addEventListener('click', () => selectObject(index));
            ui.objectListWrapper.appendChild(item);
        });
    }

    function updateDetailsPanelUI() {
        if (appState.selectedObjectIndex === -1) {
            ui.detailsWrapper.classList.add('hidden');
            return;
        }
        ui.detailsWrapper.classList.remove('hidden');
        ui.detailsWrapper.innerHTML = `
            <div id="details-header" class="flex justify-between items-center p-2">
                <h3 class="text-md font-semibold" id="details-title"></h3>
                <button id="btnDeleteObject" class="btn btn-icon btn-danger" title="선택된 객체 삭제 (Delete)"></button>
            </div>
            <div id="bbox-info" class="p-2 text-sm space-y-2"></div>
            <div id="keypoint-list" class="space-y-1 p-1"></div>
        `;
        const deleteButton = document.getElementById('btnDeleteObject');
        deleteButton.addEventListener('click', deleteSelectedObject);
        deleteButton.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm5-1a1 1 0 00-1 1v6a1 1 0 102 0V8a1 1 0 00-1-1z" clip-rule="evenodd" /></svg>`;
        document.getElementById('details-title').textContent = `객체 ${appState.selectedObjectIndex + 1} 상세정보`;
        
        updateBboxInfoUI();
        updateKeypointListUI();
    }

    function updateBboxInfoUI() {
        const bboxInfoEl = document.getElementById('bbox-info');
        if (!bboxInfoEl) return;

        const obj = annotationData[imageFiles[currentImageIndex].name].objects[appState.selectedObjectIndex];
        bboxInfoEl.innerHTML = '';
        
        const titleDiv = document.createElement('div');
        titleDiv.className = 'font-semibold text-gray-300';
        titleDiv.textContent = 'Bounding Box';
        bboxInfoEl.appendChild(titleDiv);

        if (!obj.bbox) {
            const container = document.createElement('div');
            container.className = 'flex items-center justify-between mt-1';
            container.innerHTML = `<p class="text-gray-400 text-xs">BBox 정보 없음</p>`;
            const addButton = document.createElement('button');
            addButton.textContent = '+ BBox 추가';
            addButton.className = 'btn btn-tonal text-xs py-1 px-2';
            addButton.onclick = () => enterBboxDrawingMode(appState.selectedObjectIndex);
            container.appendChild(addButton);
            bboxInfoEl.appendChild(container);
            return;
        }

        const [x1, y1, x2, y2] = obj.bbox;
        const coordsDiv = document.createElement('div');
        coordsDiv.className = 'grid grid-cols-2 gap-2 text-xs mt-1';
        coordsDiv.innerHTML = `
            <div class="flex items-center">X1: <input type="number" data-coord="0" value="${x1.toFixed(1)}" class="ml-1 w-full rounded px-1 py-0.5 text-white"></div>
            <div class="flex items-center">Y1: <input type="number" data-coord="1" value="${y1.toFixed(1)}" class="ml-1 w-full rounded px-1 py-0.5 text-white"></div>
            <div class="flex items-center">X2: <input type="number" data-coord="2" value="${x2.toFixed(1)}" class="ml-1 w-full rounded px-1 py-0.5 text-white"></div>
            <div class="flex items-center">Y2: <input type="number" data-coord="3" value="${y2.toFixed(1)}" class="ml-1 w-full rounded px-1 py-0.5 text-white"></div>
        `;
        bboxInfoEl.appendChild(coordsDiv);
        
        coordsDiv.querySelectorAll('input').forEach(input => {
            input.addEventListener('change', e => {
                saveState();
                const coordIndex = parseInt(e.target.dataset.coord);
                obj.bbox[coordIndex] = parseFloat(e.target.value);
                redrawCanvas();
            });
        });
    }

    function updateKeypointListUI() {
        const keypointListEl = document.getElementById('keypoint-list');
        if (!keypointListEl) return;
        keypointListEl.innerHTML = '';
        const points = annotationData[imageFiles[currentImageIndex].name].objects[appState.selectedObjectIndex].keypoints;
        
        config.labels.forEach((label, index) => {
            const point = points[index];
            const item = document.createElement('div');
            item.className = 'keypoint-item p-2 text-xs rounded-lg cursor-pointer transition-colors space-y-2';
            if (index === appState.selectedPointIndex) item.classList.add('selected');
            
            const visibilityRadios = [0, 1, 2].map(v => `
                <label class="inline-flex items-center">
                    <input type="radio" class="form-radio bg-gray-900 text-blue-500" name="vis-${appState.selectedObjectIndex}-${index}" value="${v}" ${point.visible === v ? 'checked' : ''}>
                    <span class="ml-1 text-gray-400">${v}</span>
                </label>
            `).join('');

            item.innerHTML = `
                <div class="flex justify-between items-center">
                    <span class="font-semibold">${index + 1}. ${label}</span>
                </div>
                <div class="grid grid-cols-2 gap-x-2 gap-y-1">
                    <div class="flex items-center">
                        <span class="mr-1 text-gray-400">X:</span>
                        <input type="number" value="${point.x.toFixed(1)}" class="w-full rounded px-1 py-0.5 text-white">
                    </div>
                    <div class="flex items-center">
                        <span class="mr-1 text-gray-400">Y:</span>
                        <input type="number" value="${point.y.toFixed(1)}" class="w-full rounded px-1 py-0.5 text-white">
                    </div>
                </div>
                <div class="flex justify-around items-center pt-1">
                    ${visibilityRadios}
                </div>
            `;

            item.addEventListener('click', (e) => {
                if (e.target.tagName !== 'INPUT') {
                    appState.selectedPointIndex = index;
                    updateAllUI();
                    redrawCanvas();
                }
            });

            const xInput = item.querySelector('input[type="number"][value*="."]');
            const yInput = item.querySelectorAll('input[type="number"]')[1];
            
            [xInput, yInput].forEach((input, i) => {
                input.addEventListener('change', (e) => {
                    saveState();
                    point[i === 0 ? 'x' : 'y'] = parseFloat(e.target.value);
                    redrawCanvas();
                });
            });

            item.querySelectorAll('input[type="radio"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    saveState();
                    point.visible = parseInt(e.target.value);
                    redrawCanvas();
                });
            });

            keypointListEl.appendChild(item);
        });
    }

    function updateInfoBarUI() {
        if (currentImageIndex < 0) {
            ui.imageName.textContent = 'N/A';
            ui.imageDimensions.textContent = '';
            ui.imageSize.textContent = '';
            return;
        };
        const file = imageFiles[currentImageIndex];
        
        ui.imageName.textContent = file.name;
        ui.imageProgress.textContent = `${currentImageIndex + 1} / ${imageFiles.length}`;
        ui.zoomLevel.textContent = `Zoom: ${(transform.scale * 100).toFixed(0)}%`;
        
        if (currentImage) ui.imageDimensions.textContent = `${currentImage.naturalWidth} x ${currentImage.naturalHeight}`;
        ui.imageSize.textContent = formatBytes(file.size);
    }
    
    // --- 핵심 로직 (파일, 네비게이션, 저장) ---
    async function handleConfigFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        try {
            const fileContent = await file.text();
            const parsedConfig = JSON.parse(fileContent);

            if (!Array.isArray(parsedConfig.labels)) throw new Error("Config 파일에 'labels' 배열이 없습니다.");
            if (!Array.isArray(parsedConfig.skeleton)) throw new Error("Config 파일에 'skeleton' 배열이 없습니다.");
            
            config = parsedConfig;
            showNotification(`${file.name} 로드 완료`, 'success');
            ui.btnLoadDir.disabled = false;
            ui.btnLoadConfig.classList.replace('btn-secondary', 'btn-success');
            ui.btnLoadConfig.textContent = 'Config 로드됨';

        } catch (error) {
            config = null;
            ui.btnLoadDir.disabled = true;
            ui.btnLoadConfig.classList.replace('btn-success', 'btn-secondary');
            ui.btnLoadConfig.textContent = 'Config 열기';
            
            let errorMessage = `설정 파일 오류: ${error.message}`;
            if (error instanceof SyntaxError) errorMessage = "설정 파일 오류: JSON 형식이 올바르지 않습니다.";
            showNotification(errorMessage, 'error');
        } finally {
            updateHelpUI();
            e.target.value = '';
        }
    }

    async function handleDirectorySelection(e) {
        showNotification('이미지 폴더를 읽는 중...', 'info');
        ui.canvasLoader.style.display = 'flex';
        try {
            const files = Array.from(e.target.files);
            imageFiles = files.filter(f => /\.(png|jpe?g)$/i.test(f.name)).sort((a,b) => a.name.localeCompare(b.name));
            jsonFiles = files.filter(f => /\.json$/i.test(f.name));

            if (imageFiles.length === 0) throw new Error('폴더에 지원하는 이미지 파일이 없습니다.');
            
            ui.btnSave.disabled = false;
            ui.btnPrev.disabled = false;
            ui.btnNext.disabled = false;
            ui.btnAddObject.disabled = false;
            
            ui.btnLoadDir.textContent = '폴더 로드됨';
            ui.btnLoadDir.classList.replace('btn-secondary', 'btn-success');

            await navigateImage(0, true);
            showNotification(`${imageFiles.length}개 이미지, ${jsonFiles.length}개 JSON 로드됨`, 'success');

        } catch (error) {
            showNotification(error.message, 'error');
            imageFiles = [];
            jsonFiles = [];
            ui.btnLoadDir.textContent = '이미지 폴더 열기';
            ui.btnLoadDir.classList.replace('btn-success', 'btn-secondary');
        } finally {
            updateHelpUI();
            ui.canvasLoader.style.display = 'none';
            e.target.value = '';
        }
    }

    async function navigateImage(direction, isInitialLoad = false) {
        const newIndex = isInitialLoad ? 0 : currentImageIndex + direction;
        if (newIndex < 0 || newIndex >= imageFiles.length) return;
        
        ui.canvasLoader.style.display = 'flex';
        try {
            const doNavigation = async () => {
                currentImageIndex = newIndex;
                resetAppState();
                await loadAndDrawImage(currentImageIndex);
            };

            if (hasChanges() && !isInitialLoad) await doNavigation();
            else await doNavigation();
        } catch (error) {
            showNotification(error.message, 'error');
        } finally {
            ui.canvasLoader.style.display = 'none';
        }
    }

    function loadAndDrawImage(index) {
        return new Promise((resolve, reject) => {
            const file = imageFiles[index];
            if (!file) return reject(new Error(`Image file at index ${index} not found.`));
            
            const img = new Image();
            img.onload = async () => {
                try {
                    currentImage = img;
                    await loadAnnotationForImage(index);
                    handleResize();
                    updateAllUI();
                    resolve();
                } catch (e) {
                    reject(e);
                }
            };
            img.onerror = () => reject(new Error(`이미지 로드 실패: ${file.name}`));
            img.src = URL.createObjectURL(file);
        });
    }

    async function loadAnnotationForImage(index) {
        const imageFilename = imageFiles[index].name;
        const jsonFilename = imageFilename.replace(/\.[^/.]+$/, "") + ".json";
        const annotationFile = jsonFiles.find(f => f.name === jsonFilename);
        
        history = [];
        currentHistoryIndex = -1;
        
        if (annotationFile) {
            try {
                const data = JSON.parse(await annotationFile.text());
                if (data.objects) {
                    annotationData[imageFilename] = data;
                } else if (data.keypoints) {
                    annotationData[imageFilename] = {
                        image_path: data.image_path,
                        objects: [{ id: `obj_${Date.now()}`, bbox: null, keypoints: data.keypoints }]
                    };
                    showNotification('이전 버전 JSON을 변환했습니다. BBox를 다시 지정해주세요.', 'info');
                }
            } catch (e) {
                showNotification(`${jsonFilename} 파싱 오류. 새로 시작합니다.`, 'error');
                annotationData[imageFilename] = { image_path: imageFilename, objects: [] };
            }
        } else {
            annotationData[imageFilename] = { image_path: imageFilename, objects: [] };
        }
        saveState(); 
    }

    function saveCurrentAnnotation() {
        if (currentImageIndex < 0) return;
        const filename = imageFiles[currentImageIndex].name;
        const output = annotationData[filename];
        
        output.objects.forEach(obj => {
            if (obj.bbox) {
                const [x1, y1, x2, y2] = obj.bbox;
                obj.bbox = [Math.min(x1, x2), Math.min(y1, y2), Math.max(x1, x2), Math.max(y1, y2)];
            }
        });

        const blob = new Blob([JSON.stringify(output, null, 2)], { type: 'application/json' });
        const a = Object.assign(document.createElement('a'), {
            href: URL.createObjectURL(blob),
            download: filename.replace(/\.[^/.]+$/, "") + ".json"
        });
        a.click();
        URL.revokeObjectURL(a.href);
        history = [];
        currentHistoryIndex = -1;
        saveState();
        showNotification(`${a.download} 저장 완료`, 'success');
    }
    
    // --- 상태 관리 ---
    function resetAppState() {
        appState.mode = 'IDLE';
        appState.selectedObjectIndex = -1;
        appState.selectedPointIndex = -1;
        appState.drawingBboxStartPoint = null;
        appState.currentBbox = null;
        appState.lastMouseWorldPos = null;
        appState.isResizingBbox = false;
        appState.resizeHandle = null;
    }

    function enterBboxDrawingMode(forObjectIndex = -1) {
        appState.mode = 'DRAWING_BBOX';
        if (forObjectIndex === -1) appState.selectedObjectIndex = -1;
        else appState.selectedObjectIndex = forObjectIndex;
        updateAllUI();
    }

    function selectObject(objIndex) {
        if (appState.selectedObjectIndex !== objIndex) {
            appState.selectedObjectIndex = objIndex;
            appState.selectedPointIndex = -1;
            appState.mode = 'EDITING_POSE';
            updateAllUI();
            redrawCanvas();
        }
    }
    
    function deleteSelectedObject() {
        if (appState.selectedObjectIndex === -1) return;
        showDeleteConfirmModal();
    }

    function performDeleteObject() {
        if (appState.selectedObjectIndex === -1) return;
        saveState();
        const objects = annotationData[imageFiles[currentImageIndex].name].objects;
        objects.splice(appState.selectedObjectIndex, 1);
        appState.selectedObjectIndex = -1;
        appState.mode = 'IDLE';
        updateAllUI();
        redrawCanvas();
        showNotification('객체 삭제됨', 'success');
    }

    function saveState() {
        if (currentImageIndex < 0) return;
        
        if (currentHistoryIndex < history.length - 1) {
            history.splice(currentHistoryIndex + 1);
        }

        const filename = imageFiles[currentImageIndex].name;
        history.push(JSON.parse(JSON.stringify(annotationData[filename].objects)));
        
        if (history.length > 31) { // Cap history size
            history.shift();
        }
        
        currentHistoryIndex = history.length - 1;
    }

    function undo() {
        if (currentHistoryIndex <= 0) {
            showNotification('더 이상 취소할 내용이 없습니다.', 'info');
            return;
        }
        currentHistoryIndex--;
        const filename = imageFiles[currentImageIndex].name;
        annotationData[filename].objects = JSON.parse(JSON.stringify(history[currentHistoryIndex]));
        
        resetAppState();
        updateAllUI();
        redrawCanvas();
        showNotification('실행 취소', 'success');
    }

    function hasChanges() { return history.length > 1; }

    // --- 렌더링 ---
    function handleResize() {
        if (!ui.canvasWrapper) return;
        const rect = ui.canvasWrapper.getBoundingClientRect();
        ui.canvas.width = rect.width;
        ui.canvas.height = rect.height;
        if (currentImage) {
            centerImage();
            redrawCanvas();
        }
    }

    function redrawCanvas() {
        if (!currentImage || !ui.ctx) return;
        const ctx = ui.ctx;
        ctx.save();
        ctx.fillStyle = '#000';
        ctx.fillRect(0, 0, ui.canvas.width, ui.canvas.height);
        
        ctx.translate(transform.offsetX, transform.offsetY);
        ctx.scale(transform.scale, transform.scale);
        
        ctx.drawImage(currentImage, 0, 0);

        if (appState.lastMouseWorldPos && !appState.isPanning) {
            drawGuideLines(appState.lastMouseWorldPos);
            drawCursorLabel(appState.lastMouseWorldPos);
        }

        const objects = annotationData[imageFiles[currentImageIndex]?.name]?.objects || [];
        
        objects.forEach((obj, index) => {
            const isSelected = index === appState.selectedObjectIndex;
            if (obj.bbox) {
                drawBbox(obj.bbox, isSelected);
                if (isSelected) drawResizeHandles(obj.bbox);
            }
            if (obj.keypoints) {
                drawSkeleton(obj.keypoints, isSelected);
                drawKeypoints(obj.keypoints, index, isSelected);
            }
        });

        if (appState.mode === 'DRAWING_BBOX' && appState.currentBbox) {
            drawBbox(appState.currentBbox, true, true);
        }
        
        ctx.restore();
    }

    function drawBbox(bbox, isSelected, isDrawing = false) {
        const [x1, y1, x2, y2] = bbox;
        ui.ctx.lineWidth = isSelected ? 4 / transform.scale : 2 / transform.scale;
        ui.ctx.strokeStyle = isSelected ? 'rgba(59, 130, 246, 1)' : 'rgba(16, 185, 129, 0.8)';
        if (isDrawing) ui.ctx.setLineDash([5, 5]);
        ui.ctx.strokeRect(Math.min(x1,x2), Math.min(y1,y2), Math.abs(x2 - x1), Math.abs(y2 - y1));
        ui.ctx.setLineDash([]);
    }

    function drawKeypoints(points, objIndex, isSelected) {
        const pointRadius = 5 / transform.scale;
        points.forEach((point, ptIndex) => {
            if (point.visible === 0) return;
            ui.ctx.beginPath();
            ui.ctx.arc(point.x, point.y, pointRadius, 0, 2 * Math.PI);
            
            const isPointSelected = isSelected && ptIndex === appState.selectedPointIndex;
            
            if (isPointSelected) ui.ctx.fillStyle = 'rgba(236, 72, 153, 1)';
            else ui.ctx.fillStyle = point.visible === 2 ? 'rgba(52, 211, 153, 0.9)' : 'rgba(251, 191, 36, 0.9)';
            
            ui.ctx.fill();
        });
    }

    function drawSkeleton(points, isSelected) {
        ui.ctx.lineWidth = 3 / transform.scale;
        ui.ctx.strokeStyle = isSelected ? 'rgba(96, 165, 250, 0.9)' : 'rgba(96, 165, 250, 0.5)';
        config.skeleton.forEach(([p1Index, p2Index]) => {
            const p1 = points[p1Index], p2 = points[p2Index];
            if (p1?.visible > 0 && p2?.visible > 0) {
                ui.ctx.beginPath();
                ui.ctx.moveTo(p1.x, p1.y);
                ui.ctx.lineTo(p2.x, p2.y);
                ui.ctx.stroke();
            }
        });
    }

    function drawGuideLines(pos) {
        if (!currentImage) return;
        const ctx = ui.ctx;
        ctx.save();
        ctx.strokeStyle = 'rgba(59, 130, 246, 0.7)';
        ctx.lineWidth = 1 / transform.scale;
        ctx.setLineDash([]);

        ctx.beginPath();
        ctx.moveTo(0, pos.y);
        ctx.lineTo(currentImage.width, pos.y);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(pos.x, 0);
        ctx.lineTo(pos.x, currentImage.height);
        ctx.stroke();

        ctx.restore();
    }

    function drawResizeHandles(bbox) {
        const [x1, y1, x2, y2] = bbox;
        const handles = { tl: [x1, y1], tr: [x2, y1], bl: [x1, y2], br: [x2, y2] };
        const handleSize = 8 / transform.scale;
        ui.ctx.fillStyle = 'rgba(59, 130, 246, 1)';
        ui.ctx.strokeStyle = 'rgba(255, 255, 255, 1)';
        ui.ctx.lineWidth = 1.5 / transform.scale;

        for (const key in handles) {
            const [x, y] = handles[key];
            ui.ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
            ui.ctx.strokeRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
        }
    }

    function drawCursorLabel(pos) {
        if (appState.mode !== 'EDITING_POSE' || appState.selectedPointIndex === -1) return;

        const label = config.labels[appState.selectedPointIndex];
        const ctx = ui.ctx;
        ctx.save();
        
        const fontSize = 14 / transform.scale;
        ctx.font = `bold ${fontSize}px Inter`;
        const textMetrics = ctx.measureText(label);
        const textWidth = textMetrics.width;
        const textHeight = fontSize;
        const padding = 5 / transform.scale;
        
        const x = pos.x + 15 / transform.scale;
        const y = pos.y + 15 / transform.scale;

        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(x, y, textWidth + padding * 2, textHeight + padding * 2);
        
        ctx.fillStyle = 'white';
        ctx.fillText(label, x + padding, y + textHeight + padding / 2);
        
        ctx.restore();
    }

    // --- 마우스 및 키보드 이벤트 핸들러 ---
    function handleMouseDown(e) {
        if (!config || currentImageIndex < 0) return;
        
        if (e.altKey) {
            appState.isPanning = true;
            appState.lastPanPoint = { x: e.clientX, y: e.clientY };
            ui.canvas.style.cursor = 'grabbing';
            redrawCanvas();
            return;
        }

        const pos = getMousePos(ui.canvas, e);
        const worldPos = screenToWorld(pos.x, pos.y);

        if (appState.mode === 'DRAWING_BBOX') {
            appState.drawingBboxStartPoint = worldPos;
            appState.currentBbox = [worldPos.x, worldPos.y, worldPos.x, worldPos.y];
            return;
        }
        
        const objects = annotationData[imageFiles[currentImageIndex].name].objects;
        const clickRadius = 8 / transform.scale;

        if (appState.selectedObjectIndex !== -1) {
            const selectedObject = objects[appState.selectedObjectIndex];
            const handle = getResizeHandleAt(worldPos, selectedObject.bbox);
            if (handle) {
                saveState();
                appState.isResizingBbox = true;
                appState.resizeHandle = handle;
                return;
            }
        }

        if (appState.mode === 'EDITING_POSE' && appState.selectedObjectIndex !== -1) {
            const selectedObject = objects[appState.selectedObjectIndex];
            for (let j = 0; j < selectedObject.keypoints.length; j++) {
                const p = selectedObject.keypoints[j];
                if (p.visible > 0 && Math.hypot(p.x - worldPos.x, p.y - worldPos.y) < clickRadius) {
                    saveState();
                    appState.isDraggingPoint = true;
                    appState.draggingPointInfo = { objIndex: appState.selectedObjectIndex, ptIndex: j };
                    appState.selectedPointIndex = j;
                    updateAllUI();
                    redrawCanvas();
                    return;
                }
            }
            if (appState.selectedPointIndex !== -1 && isPointInBbox(worldPos, selectedObject.bbox)) {
                saveState();
                const pointToUpdate = selectedObject.keypoints[appState.selectedPointIndex];
                pointToUpdate.x = worldPos.x;
                pointToUpdate.y = worldPos.y;
                pointToUpdate.visible = 2;
                const nextPointIndex = (appState.selectedPointIndex + 1) % config.labels.length;
                appState.selectedPointIndex = nextPointIndex;
                updateAllUI();
                redrawCanvas();
                return;
            }
        }
        
        for (let i = objects.length - 1; i >= 0; i--) {
            if (isPointInBbox(worldPos, objects[i].bbox)) {
                if (appState.selectedObjectIndex !== i) {
                    selectObject(i);
                }
                appState.isDraggingBbox = true;
                return;
            }
        }

        if (appState.selectedObjectIndex !== -1) {
            appState.selectedObjectIndex = -1;
            appState.selectedPointIndex = -1;
            appState.mode = 'IDLE';
            updateAllUI();
            redrawCanvas();
        }
    }

    function handleMouseMove(e) {
        const pos = getMousePos(ui.canvas, e);
        const worldPos = screenToWorld(pos.x, pos.y);
        appState.lastMouseWorldPos = worldPos;

        if (appState.isPanning) {
            const dx = e.clientX - appState.lastPanPoint.x;
            const dy = e.clientY - appState.lastPanPoint.y;
            transform.offsetX += dx;
            transform.offsetY += dy;
            appState.lastPanPoint = { x: e.clientX, y: e.clientY };
        } else if (appState.isResizingBbox) {
            const bbox = annotationData[imageFiles[currentImageIndex].name].objects[appState.selectedObjectIndex].bbox;
            switch (appState.resizeHandle) {
                case 'tl': bbox[0] = worldPos.x; bbox[1] = worldPos.y; break;
                case 'tr': bbox[2] = worldPos.x; bbox[1] = worldPos.y; break;
                case 'bl': bbox[0] = worldPos.x; bbox[3] = worldPos.y; break;
                case 'br': bbox[2] = worldPos.x; bbox[3] = worldPos.y; break;
            }
            updateBboxInfoUI();
        } else if (appState.mode === 'DRAWING_BBOX' && appState.drawingBboxStartPoint) {
            appState.currentBbox[2] = worldPos.x;
            appState.currentBbox[3] = worldPos.y;
        } else if (appState.isDraggingPoint) {
            const { objIndex, ptIndex } = appState.draggingPointInfo;
            const point = annotationData[imageFiles[currentImageIndex].name].objects[objIndex].keypoints[ptIndex];
            point.x = worldPos.x;
            point.y = worldPos.y;
            updateKeypointListUI();
        }
        
        redrawCanvas();
    }

    function handleMouseUp(e) {
        if (appState.mode === 'DRAWING_BBOX' && appState.currentBbox) {
            let newObjectIndex = -1;
            if (appState.selectedObjectIndex !== -1) {
                const obj = annotationData[imageFiles[currentImageIndex].name].objects[appState.selectedObjectIndex];
                obj.bbox = [...appState.currentBbox];
                newObjectIndex = appState.selectedObjectIndex;
            } else {
                const newObject = {
                    id: `obj_${Date.now()}`,
                    bbox: [...appState.currentBbox],
                    keypoints: config.labels.map(labelName => ({ name: labelName, x: 0, y: 0, visible: 0 }))
                };
                annotationData[imageFiles[currentImageIndex].name].objects.push(newObject);
                newObjectIndex = annotationData[imageFiles[currentImageIndex].name].objects.length - 1;
            }
            
            selectObject(newObjectIndex);
            appState.selectedPointIndex = 0; // Start with the first keypoint
            
            appState.drawingBboxStartPoint = null;
            appState.currentBbox = null;
            saveState();
            updateAllUI();
        }
        
        if (e.type === 'mouseout') appState.lastMouseWorldPos = null;
        
        appState.isPanning = false;
        appState.isDraggingPoint = false;
        appState.isDraggingBbox = false;
        appState.isResizingBbox = false;
        appState.resizeHandle = null;
        if (!appState.isAltDown) ui.canvas.style.cursor = 'crosshair';
        redrawCanvas();
    }
    
    async function handleKeyDown(e) {
        if (e.repeat) return;
        if (e.key === 'Alt') {
            appState.isAltDown = true;
            if (!appState.isPanning) ui.canvas.style.cursor = 'grab';
        }
        if (e.altKey || e.target.tagName === 'INPUT') return;
        switch (e.key.toLowerCase()) {
            case 'a': e.preventDefault(); enterBboxDrawingMode(); break;
            case 's': e.preventDefault(); saveCurrentAnnotation(); break;
            case 'z': if (e.ctrlKey || e.metaKey) { e.preventDefault(); undo(); } break;
            case 'escape': 
                e.preventDefault();
                appState.mode = 'IDLE';
                appState.selectedObjectIndex = -1;
                updateAllUI();
                redrawCanvas();
                break;
            case 'delete': case 'backspace':
                e.preventDefault();
                deleteSelectedObject();
                break;
            case 'arrowright': await navigateImage(1); break;
            case 'arrowleft': await navigateImage(-1); break;
        }
    }

    function handleKeyUp(e) {
        if (e.key === 'Alt') {
            appState.isAltDown = false;
            if (!appState.isPanning) ui.canvas.style.cursor = 'crosshair';
        }
    }

    function handleWheelZoom(e) {
        e.preventDefault();
        const pos = getMousePos(ui.canvas, e);
        const zoomIntensity = 0.1;
        const wheel = e.deltaY < 0 ? 1 : -1;
        const zoom = Math.exp(wheel * zoomIntensity);
        const worldPos = screenToWorld(pos.x, pos.y);
        
        transform.scale = Math.max(0.05, Math.min(20, transform.scale * zoom));
        transform.offsetX = pos.x - worldPos.x * transform.scale;
        transform.offsetY = pos.y - worldPos.y * transform.scale;
        
        redrawCanvas();
        updateInfoBarUI();
    }

    // --- 유틸리티 ---
    function centerImage() {
        if (!currentImage) return;
        const scaleX = ui.canvas.width / currentImage.width;
        const scaleY = ui.canvas.height / currentImage.height;
        transform.scale = Math.min(scaleX, scaleY) * 0.95;
        transform.offsetX = (ui.canvas.width - currentImage.width * transform.scale) / 2;
        transform.offsetY = (ui.canvas.height - currentImage.height * transform.scale) / 2;
    }
    function screenToWorld(x, y) { return { x: (x - transform.offsetX) / transform.scale, y: (y - transform.offsetY) / transform.scale }; }
    function getMousePos(canvas, evt) { const rect = canvas.getBoundingClientRect(); return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; }
    function isPointInBbox(point, bbox) {
        if (!bbox) return false;
        const [x1, y1, x2, y2] = bbox;
        return point.x >= Math.min(x1, x2) && point.x <= Math.max(x1, x2) &&
               point.y >= Math.min(y1, y2) && point.y <= Math.max(y1, y2);
    }
    
    function formatBytes(bytes, decimals = 2) {
        if (bytes === 0) return '0 Bytes';
        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB'];
        const i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    function showNotification(message, type = 'info') {
        clearTimeout(notificationTimeout);
        const el = ui.toastPopup;
        el.textContent = message;

        el.className = 'toast-popup'; // Reset classes
        el.classList.add(type);
        el.classList.add('show');

        notificationTimeout = setTimeout(() => {
            el.classList.remove('show');
        }, 2500);
    }

    function getResizeHandleAt(worldPos, bbox) {
        if (!bbox) return null;
        const [x1, y1, x2, y2] = bbox;
        const handleSize = 8 / transform.scale;
        const handles = { tl: [x1, y1], tr: [x2, y1], bl: [x1, y2], br: [x2, y2] };
        for (const key in handles) {
            const [hx, hy] = handles[key];
            if (Math.abs(worldPos.x - hx) < handleSize / 2 && Math.abs(worldPos.y - hy) < handleSize / 2) {
                return key;
            }
        }
        return null;
    }
    
    function showDeleteConfirmModal() {
        const modal = document.createElement('div');
        modal.id = 'deleteConfirmModal';
        modal.className = 'fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center z-50';
        modal.innerHTML = `
            <div class="p-6 rounded-2xl shadow-xl" style="background-color: var(--md-sys-color-surface-container-high);">
                <h3 class="text-lg font-bold mb-2">객체 삭제</h3>
                <p class="text-sm mb-6" style="color: var(--md-sys-color-on-surface-variant);">이 객체를 정말 삭제하시겠습니까?</p>
                <div class="flex justify-end gap-4">
                    <button id="btnModalCancel" class="btn btn-tonal">취소</button>
                    <button id="btnModalConfirm" class="btn btn-danger">삭제</button>
                </div>
            </div>
        `;
        document.body.appendChild(modal);
        document.getElementById('btnModalConfirm').addEventListener('click', () => {
            performDeleteObject();
            hideDeleteConfirmModal();
        });
        document.getElementById('btnModalCancel').addEventListener('click', hideDeleteConfirmModal);
    }

    function hideDeleteConfirmModal() {
        const modal = document.getElementById('deleteConfirmModal');
        if (modal) modal.remove();
    }

    // --- 초기화 및 이벤트 리스너 ---
    function initialize() {
        // DOM 요소 바인딩
        Object.assign(ui, {
            btnLoadConfig: document.getElementById('btnLoadConfig'),
            configLoader: document.getElementById('configLoader'),
            btnLoadDir: document.getElementById('btnLoadDir'),
            dirLoader: document.getElementById('dirLoader'),
            btnSave: document.getElementById('btnSave'),
            btnPrev: document.getElementById('btnPrev'),
            btnNext: document.getElementById('btnNext'),
            imageProgress: document.getElementById('imageProgress'),
            imageName: document.getElementById('imageName'),
            zoomLevel: document.getElementById('zoomLevel'),
            canvas: document.getElementById('mainCanvas'),
            ctx: document.getElementById('mainCanvas').getContext('2d'),
            canvasWrapper: document.getElementById('canvas-wrapper'),
            canvasLoader: document.getElementById('canvas-loader'),
            btnAddObject: document.getElementById('btnAddObject'),
            configHelp: document.getElementById('config-help'),
            objectListWrapper: document.getElementById('object-list-wrapper'),
            detailsWrapper: document.getElementById('details-wrapper'),
            modeIndicator: document.getElementById('mode-indicator'),
            toastPopup: document.getElementById('toast-popup'),
        });
        
        // 아이콘 SVG 및 푸터 내용 삽입
        ui.btnPrev.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M12.707 5.293a1 1 0 010 1.414L9.414 10l3.293 3.293a1 1 0 01-1.414 1.414l-4-4a1 1 0 010-1.414l4-4a1 1 0 011.414 0z" clip-rule="evenodd" /></svg>`;
        ui.btnNext.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fill-rule="evenodd" d="M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z" clip-rule="evenodd" /></svg>`;
        ui.canvasLoader.innerHTML = `<svg class="animate-spin -ml-1 mr-3 h-8 w-8 text-white mb-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><p>이미지 로딩 중...</p>`;
        document.querySelector('footer').innerHTML = `<div class="flex items-center gap-x-4 gap-y-1 flex-wrap"><p id="imageName" class="font-semibold truncate">N/A</p><p id="imageDimensions" style="color: var(--md-sys-color-on-surface-variant);"></p><p id="imageSize" style="color: var(--md-sys-color-on-surface-variant);"></p></div><div class="flex items-center gap-4"><p id="notificationMessage" class="transition-colors duration-300"></p><p id="zoomLevel" style="color: var(--md-sys-color-on-surface-variant);">Zoom: 100%</p></div>`;
        Object.assign(ui, { imageName: document.getElementById('imageName'), imageDimensions: document.getElementById('imageDimensions'), imageSize: document.getElementById('imageSize'), notificationMessage: document.getElementById('notificationMessage'), zoomLevel: document.getElementById('zoomLevel')});


        // 이벤트 리스너 설정
        ui.btnLoadConfig.addEventListener('click', () => ui.configLoader.click());
        ui.configLoader.addEventListener('change', handleConfigFile);
        ui.btnLoadDir.addEventListener('click', () => ui.dirLoader.click());
        ui.dirLoader.addEventListener('change', handleDirectorySelection);
        ui.btnSave.addEventListener('click', saveCurrentAnnotation);
        ui.btnPrev.addEventListener('click', () => navigateImage(-1));
        ui.btnNext.addEventListener('click', () => navigateImage(1));
        ui.btnAddObject.addEventListener('click', () => enterBboxDrawingMode());

        ui.canvas.addEventListener('mousedown', handleMouseDown);
        ui.canvas.addEventListener('mousemove', handleMouseMove);
        ui.canvas.addEventListener('mouseup', handleMouseUp);
        ui.canvas.addEventListener('mouseout', handleMouseUp);
        ui.canvas.addEventListener('wheel', handleWheelZoom);
        ui.canvas.addEventListener('contextmenu', e => e.preventDefault());

        window.addEventListener('keydown', handleKeyDown);
        window.addEventListener('keyup', handleKeyUp);
        window.addEventListener('resize', handleResize);
        
        updateHelpUI();
    }

    // --- 앱 시작 ---
    initialize();
    </script>
</body>
</html>
